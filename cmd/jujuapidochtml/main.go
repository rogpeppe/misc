// The jujuapidochtml renders JSON output from jujuapidoc into
// HTML.
//
// A copy of the output of jujuapidoc as of Juju revision a0fffc4169831e
// can be found at http://rogpeppe-scratch.s3.amazonaws.com/juju-api.json
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"

	"github.com/rogpeppe/apicompat/jsontypes"

	"github.com/rogpeppe/misc/cmd/jujuapidoc/apidoc"
)

var htmlTmpl = `
<html>
<head>
<style>
	body {
		font-family: Ubuntu Light, sans-serif;
		padding: 25px;
	}
	h2 a {
		color: black;
		text-decoration: none;
	}
	h2 a:hover {
		text-decoration: underline;
	}
	h2 + p {
		padding-left: 25px;
	}
	tr:nth-child(even) {
		background-color: #f1f1f1;
	}
	td {
		vertical-align: top;
		padding: 10px;
	}
</style>
<title>Juju API docs (autogenerated)</title>
</head>
<body>
<h1>Juju API facades</h1>
{{range .Facades}}
	<h2 id="{{.Name}}"><a href="#{{.Name}}">{{.Name}}</a> v{{.Version}} <span style="font-size:80%;font-style: italic">{{.AvailableTo | join " "}}</span></h2>
	<p>{{.Doc}}</p>
	<table>
		<tr>
			<th>Name</th>
			<th>Params</th>
			<th>Results</th>
			<th>Description</th>
		</tr>
		{{range .Methods}}
			<tr>
				<td>{{.Name}}</td>
				<td>{{.Param | typeLink}}</td>
				<td>{{.Result | typeLink}}</td>
				<td>{{.Doc}}</td>
			</tr>
		{{end}}
	</table>
{{end}}
</body>
</html>
`

func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "usage: jujuapidochtml api.json [role...]\n")
		os.Exit(2)
	}
	flag.Parse()

	if flag.NArg() < 1 {
		flag.Usage()
	}
	roles := make(map[string]bool)
	for _, role := range flag.Args()[1:] {
		roles[role] = true
	}

	data, err := ioutil.ReadFile(flag.Arg(0))
	if err != nil {
		log.Fatal(err)
	}
	var info *apidoc.Info
	if err := json.Unmarshal(data, &info); err != nil {
		log.Fatal(err)
	}
	sort.Slice(info.Facades, func(i, j int) bool {
		f1, f2 := info.Facades[i], info.Facades[j]
		if f1.Name != f2.Name {
			return f1.Name < f2.Name
		}
		return f1.Version > f2.Version
	})
	seen := make(map[string]bool)
	facades := make([]apidoc.FacadeInfo, 0, len(info.Facades))
	for _, f := range info.Facades {
		if seen[f.Name] {
			continue
		}
		if len(roles) > 0 {
			found := false
			for _, role := range f.AvailableTo {
				if roles[role] {
					found = true
					break
				}
			}
			if !found {
				continue
			}
		}
		facades = append(facades, f)
		seen[f.Name] = true
	}
	info.Facades = facades

	t, err := template.New("").Funcs(tmplFuncs).Parse(htmlTmpl)
	if err != nil {
		log.Fatal(err)
	}
	if err := t.Execute(os.Stdout, info); err != nil {
		log.Fatal(err)
	}
}

var tmplFuncs = template.FuncMap{
	"typeLink": func(t *jsontypes.Type) template.HTML {
		if t == nil {
			return "n/a"
		}
		link := fmt.Sprintf(`<a href="https://godoc.org/%s">%s</a>`, t.Name, t.Name.Name())
		return template.HTML(link)
	},
	"join": func(sep string, ss []string) string {
		return strings.Join(ss, sep)
	},
}
